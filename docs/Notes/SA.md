## 前言

后缀数组板子一遍过了，开心。

这篇学习笔记整体框架上与 OI-Wiki 相似，但保证本文章完全原创（“记号与约定”部分除外）。

前置知识：基数排序、倍增。

## 记号与约定

字符串即为 $s$。

记 "后缀 $i$" 表示从 $i$ 开始的后缀，即 $s[i\dots n]$，它代表后缀的编号。

记 $sa[i]$ 表示排名为 $i$ 的后缀的编号，$rk[i]$ 表示后缀 $i$ 的排名。显然有 $sa[rk[i]] = rk[sa[i]] = i$。

剩下的数组下文会说。

## 求法

### $O(n^2\log n)$ 做法

暴力对每个后缀进行排序，每次比较的复杂度为 $O(n)$，排序复杂度为 $O(n\log n)$，总复杂度 $O(n^2\log n)$。

### $O(n \log^2{n})$ 做法

对于字符串 $s$ 的所有后缀，它们有大量重复部分，而直接排序就会进行大量重复比较，不如换个角度入手。

我们先从一组数据入手。对于 $s = \texttt{abbaaaba}$，我们先以每个后缀第一个字符为第一关键字，第二个字符为第二关键字进行排序，其实也就是对于每个后缀的前两个字符进行排序，结果如下：

![](images/img1.png)

观察这些后缀，我们发现，绿色部分是已经有序了，也就是说我们知道绿色部分的排名。而由后缀的性质，蓝色部分其实也是一个后缀，那么其实我们也知道下图中黄色部分的排名：

![](images/img2.png)

那么我们使用绿色部分的排名（即原排名，$rk$ 数组）为第一关键字，黄色部分的排名（即对于后缀 $i$，第一个图的蓝色部分是后缀 $i + 2$，那么黄色部分的排名即为后缀 $i + 2$ 的原排名，即 $rk[i + 2]$）为第二关键字，进行排序，结果如下：

![](images/img3.png)

很好，现在绿色部分（已排序部分）的长度由 $2$ 变为了 $4$。我们接下来再选取长度为 $4$ 的黄色部分，这样，我们就成功对后缀的前 $8$ 个字符排序了。以此类推，我们每次都倍增排序长度，并且重复以上操作，那么我们就可以在 $O(n \log^2{n})$ 的复杂度内解决掉这个问题了（排序 $O(n\log n)$，倍增 $O(\log n)$）。

???+ note "形式化的解法"
    设需要排序长度为 $w$。
    
    对于后缀 $i$，我们知道按它的第 $1$ 个字符到第 $w/2$ 个字符排序的排名。对于后缀 $i + w/2$ 也是如此，这相当于我们知道按后缀 $i$ 的第 $w/2 + 1$ 个字符到第 $w$ 个字符排序的排名。那么我们以 $rk[i]$ 为第一关键字，$rk[i+w/2]$ 为第二关键字进行排序即可。

    倍增 $w$，即 $w \gets 2 \times w$。

### $O(n \log{n})$ 做法

字符串有一个特点：值域小。也就是说每个位置的取值种类少。这样，我们就可以利用基数排序的思想。

具体地，先按第一个关键字扔进桶里，再按从大到小按第二关键字遍历桶即可。

???+ note "核心代码"
    懒得写伪代码了，直接放代码吧。
    ```cpp
    /*
    b数组是桶。rk、sa同上。
    tp[i]表示，第二关键字排名为i的后缀编号。
    */
    void f_sort() {
        for (int i = 1; i <= m; i++) b[i] = 0;
        for (int i = 1; i <= n; i++) b[rk[i]]++;
        for (int i = 1; i <= m; i++) b[i] += b[i - 1];
        //做前缀和，方便统计排名。
        for (int i = n; i >= 1; i--) sa[b[rk[tp[i]]]--] = tp[i];
        //rk[tp[i]]表示的是第二关键字排名为i的后缀的第一关键字。
        //这步较为复杂，多看看，手模一下。
    }
    ```

可以看到，这样排序的复杂度是 $O(n)$。我们成功地将总复杂度优化为 $O(n\log n)$。

我们求出 $sa$ 数组了之后，不能直接用 $rk[sa[i]] = i$ 给 $rk$ 赋值，这是因为有可能有些后缀的第一二关键字都相同，那么它们的排名也相同，这需要特判一下。

容易观察到第二关键字是由第一关键字平移得到，那么我们就可以 $O(n)$ 求第二关键字。而且第二关键字我们只需要排名，可以进行一点小优化。具体实现见代码。

??? note "完整代码"
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 1e6 + 10;
    int n, m;
    int sa[N], rk[N];
    int b[N], tp[N];
    char c[N];

    void f_sort() {
        for (int i = 1; i <= m; i++) b[i] = 0;
        for (int i = 1; i <= n; i++) b[rk[i]]++;
        for (int i = 1; i <= m; i++) b[i] += b[i - 1];
        for (int i = n; i >= 1; i--) sa[b[rk[tp[i]]]--] = tp[i];
    }
    void g_sa() {
        for (int i = 1; i <= n; i++) rk[i] = c[i], tp[i] = i;
        f_sort();
        int p = 0;
        for (int w = 1; w <= n; w <<= 1) {
            if (p >= n) break;
            p = 0;
            for (int i = n - w + 1; i <= n; i++) tp[++p] = i;
            for (int i = 1; i <= n; i++) {
                if (sa[i] > w) tp[++p] = sa[i] - w;
            }
            f_sort(), swap(rk, tp), rk[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) {
                int sl = sa[i - 1], sr = sa[i]; 
                if (tp[sl] == tp[sr] && tp[sl + w] == tp[sr + w]) {
                    rk[sa[i]] = p;
                } else rk[sa[i]] = ++p;
            }
            m = p;
        }
    }

    int main() {
        scanf("%s", c + 1);
        n = strlen(c + 1), m = 127;
        g_sa();
        for (int i = 1; i <= n; i++) {
            printf("%d ", sa[i]);
        }
        return 0;
    }
    ```

未完待续...